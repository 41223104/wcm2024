var tipuesearch = {"pages": [{'title': 'About', 'text': '網頁:\xa0 https://41223104.github.io/wcm2024/ \n 網誌:\xa0 https://41223104.github.io/wcm2024/blog/ \n 簡報:\xa0 https://41223104.github.io/wcm2024/reveal/ \n 倉儲:    https://github.com/41223104/wcm2024 \n 本 cmsimde 網際內容管理系統的對應 Template 倉儲: \n https://github.com/mdecycu/cmsimde_site \n 此 Template 將 cmsimde 作為子目錄而非子模組, 使用者可以依照需求自行修改 \n 倉儲對應網站:  https://mde.tw/cmsimde_site \n', 'tags': '', 'url': 'About.html'}, {'title': '作業', 'text': '', 'tags': '', 'url': '作業.html'}, {'title': 'W2', 'text': '1.確認所有學員已經建立帳號: 帶有以 Python 編寫的動態網站程式, 以及位於 content 目錄中的靜態網頁資料. \n 2. 確認學員會用replit維護網站:Replit 檢視動態網站或網誌推送到 Github 之前的內容, 必須要在動態與靜態模式中擇一使用 \n 3.如何利用Codespaces維護網站:Codespaces 中維護 wcm2024 的過程幾乎如同在 localhost Windows 10 或 11 的操作系統環境中進行 \n', 'tags': '', 'url': 'W2.html'}, {'title': 'W3', 'text': '', 'tags': '', 'url': 'W3.html'}, {'title': 'W4', 'text': '有關建立網站: 網站指的是 Web site針對網頁瀏覽器檢視的內容加以管理，利用 Github 所提供的 Pages 功能來建立網頁進行管理。 \n Replit靜態網站檢視:若要執行動態網站，可以在 Shell 執行 python3 main.py 或者使用 Replit 的 Run 按鍵，\xa0Shell 執行 python3 main2.py 就可以執行倉儲內的靜態網站檢視。 \n Replit建立分組倉儲權限： \n 分組網站 import 到 Replit, 必須自行在 /home/runner/.ssh 目錄下建立 id_rsa 與 config (id_rsa.pub 必須登錄到 Github 對應帳號), 其中的 config 內容為: \n Host github.com\nUser git\nHostname github.com \n ssh.py 程式內容如下： \n import os\nif not os.path.exists("/home/runner/.ssh"): \n    os.makedirs("/home/runner/.ssh") \nos.system("mv ./downloads/id_rsa.txt /home/runner/.ssh/id_rsa")\nos.system("mv ./downloads/config.txt /home/runner/.ssh/config")\nos.system("chmod og-rwx /home/runner/.ssh/id_rsa") \n \n', 'tags': '', 'url': 'W4.html'}, {'title': 'W5', 'text': '以 iframe 嵌入先前的教學影片做課前預習 \n 1.在Replit 平台上的分組倉儲權限設定 \n 2.Putty Solvespace STL 零件檢視方法 \n 3.大規模人工智慧運算的時代：前景、影響及回應 \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': '向ChatGPT詢問Git的歷史以及如何將Git應用於機械設計相關專業領域的工作上 \n \n', 'tags': '', 'url': 'W6.html'}, {'title': 'Git的歷史及創作人', 'text': '\n \n \n \n \n \n \n \n \n \n \n \n 問題： 請問git 的發展歷史，還有git想要解決甚麼問題? \n ChatGPT的Ans： \n Git 是由 Linus Torvalds 在 2005 年開始開發的分散式版本控制系統。以下是 Git 的發展歷史和它想要解決的問題： \n \n \n 誕生（2005年） ： \n \n Git 的開發始於 Linus Torvalds 對 Linux 內核版本控制系統 BitKeeper 的使用問題。由於許可證問題，BitKeeper 對 Linux 內核社區的使用受到限制，因此 Linus Torvalds 決定開發一個替代方案。 \n \n \n \n 首次發布（2005年） ： \n \n Git 的首次發布是在 2005 年。最初的版本已經具備基本的版本控制功能，包括提交、分支和合併等。 \n \n \n \n 社區支持（2005年至今） ： \n \n Git 很快得到了開源社區的廣泛支持和貢獻。許多開發者開始使用 Git 來管理他們的專案，並為 Git 做出了貢獻，改進了其性能和功能。 \n \n \n \n Github 的出現（2008年） ： \n \n Github 是一個基於 Git 的程式碼托管平台，於 2008 年推出。它的出現極大地促進了 Git 的普及和使用，成為了全球最大的程式碼托管平台之一。 \n \n \n \n 持續發展（2005年至今） ： \n \n 自 Git 誕生以來，它持續得到改進和發展。許多功能不斷被添加進來，性能得到了提高，以滿足日益增長的開發需求。 \n \n \n \n 廣泛應用（2005年至今） ： \n \n Git 已成為了許多軟體開發團隊的標準版本控制系統，並得到了廣泛的應用。無論是小型團隊還是大型企業，Git 都成為了他們管理程式碼的首選工具之一。 \n \n \n \n GitLab 和 Bitbucket 的出現（2011年和2008年） ： \n \n 除了 Github 外，還出現了其他的 Git 托管平台，如 GitLab 和 Bitbucket。它們為開發者提供了另外的選擇，推動了 Git 在專案托管方面的進一步發展。 \n \n \n \n 持續改進（2005年至今） ： \n \n Git 的開發和改進仍在持續進行中。Git 社區不斷收集用戶反饋，修復 bug，增加新功能，以確保 Git 保持在版本控制系統領域的領先地位。 \n \n \n \n Git 的目標是解決分散式軟體開發中的版本控制問題。它旨在提供一個高效、靈活且易於使用的工具，使開發者能夠有效地管理專案的版本，進行協作開發，並在需要時輕鬆地進行代碼更改的追蹤和回滾。 \n -Git創作人 \n Linus Torvalds 是 Git 的創始人之一，他是一位芬蘭的計算機科學家，最著名的貢獻是 Linux 作業系統的創建。 \n \n \n 出生： \xa0 Linus Benedict Torvalds 於 1969 年 12 月 28 日出生於芬蘭赫爾辛基市。 \n \n \n 教育背景： \xa0在赫爾辛基大學學習計算機科學，於 1996 年獲得碩士學位。 \n \n \n Linux 的創建： \xa0 在大學期間，開始編寫 Linux 作業系統的原始版本。於 1991 年發布了第一個版本，這使得他成為了自由軟體和開源軟體運動的重要人物之一。 \n \n \n Git 的開發： \xa0 Linus Torvalds 在 2005 年開始為 Linux 內核開發一個新的版本控制系統，即 Git。他因對 BitKeeper 版本控制系統的不滿而啟動了這個項目。 \n \n \n 個人特點： \xa0 Linus Torvalds 以他的直率和技術才能而聞名。他通常在互聯網上以非常直接的方式進行溝通，並且對於程式碼的品質和系統的性能有著非常高的要求。 \n \n \n 對開源社區的貢獻： \xa0 除了 Linux 和 Git 外，還是開源社區的活躍參與者，並且經常在各種技術討論中發表見解。 \n \n \n 獲獎與榮譽： \xa0在計算機科學領域的貢獻獲得了許多獎項和榮譽，包括ACM計算機系統獎、圖靈獎等。 \n \n \n 總的來說，Linus Torvalds 以他的技術才能和對開源運動的貢獻而聞名於世，他的創作不僅對計算機科學領域產生了深遠的影響，也影響了整個軟體工程界。 \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'Git的歷史及創作人.html'}, {'title': 'Git能解決的專業領域問題', 'text': '\n \n 問題： 一名機械設計工程師，能如何應用Git解決AutoCAD的製圖相關問題? \n ChatGPT的Ans： \n \n \n \n \n \n \n \n \n \n \n \n \n 機械設計工程師可以利用 Git 來解決 AutoCAD 製圖相關的問題，提高團隊協作效率和版本管理。以下是一些應用 Git 的方式： \n \n \n 版本控制：  使用 Git 對 AutoCAD 圖紙進行版本控制，可以輕鬆追蹤圖紙的修改歷史、恢復到之前的版本，並避免不同版本之間的混淆和衝突。 \n \n \n 分支管理：  使用 Git 的分支功能來處理不同的圖紙修改和實驗性功能。例如，可以在不影響主要工作流程的情況下，創建新的分支來實驗不同的設計方案或修改。 \n \n \n 協作開發：  團隊成員可以通過 Git 分享和協作開發 AutoCAD 圖紙。他們可以在各自的本地環境中進行工作，然後通過 Git 將更改推送到共享的存儲庫中，以便其他人審查、合併和反饋。 \n \n \n 衝突解決：  當多個工程師同時修改同一個圖紙時，可能會發生衝突。Git 提供了衝突解決的工具和機制，可以幫助團隊成員快速解決衝突，合併不同的修改。 \n \n \n 審查和討論：  通過 Git 的分支和提交歷史，團隊可以方便地進行審查和討論圖紙的修改。成員可以針對特定的提交或分支提出反饋，以改進設計和解決問題。 \n \n \n 總的來說，將 Git 整合到 AutoCAD 製圖流程中，可以提高團隊的效率、管理圖紙的版本和更改，並促進團隊成員之間的協作和溝通。 \n', 'tags': '', 'url': 'Git能解決的專業領域問題.html'}, {'title': '議題2', 'text': '在 Windows 實際 demo git client(客戶端) 與 git server(服務器)， 該如何進行? \n \n \n \n \n \n \n \n \n \n \n \n \n -設置 Git 伺服器 \n \n \n 選擇伺服器軟體 ：在 Windows 上，可以使用像 GitLab、Bitbucket、Gogs 或 Gitea 這樣的工具來建立 Git 伺服器。這些工具提供了簡單的安裝和管理界面。 \n \n \n 安裝 Git 伺服器 ：根據選擇的工具，下載並按照其官方文件的指示安裝 Git 伺服器。 \n \n \n 配置 Git 伺服器 ：在安裝完成後，按照文件指示進行必要的配置，例如建立管理員帳戶、設置存儲庫等。 \n \n \n 啟動 Git 伺服器服務 ：根據選擇的工具，啟動 Git 伺服器服務。 \n \n \n -設置 Git 客戶端 \n \n \n 安裝 Git ：如果 Windows 系統尚未安裝 Git 客戶端，可以從  Git 官方網站  下載安裝程序，並按照提示進行安裝。 \n \n \n 配置 Git 客戶端 ：打開 Git Bash（Git 命令行工具），設置使用者信息： \n \n \n \n git config --global user.name "你的名字"\ngit config --global user.email "你的郵件@example.com" \n \n \n 建立本地倉庫 ：在電腦上建立一個本地 Git 倉庫： \n \n \n mkdir my_project\ncd my_project\ngit init \n \n \n \n \n -連接 Git 客戶端和伺服器 \n \n \n 新增遠端倉庫 ：將本地倉庫與遠端 Git 伺服器關聯： \n \n \n \n git remote add origin <伺服器位址> \n \n \n \n 這裡的  <伺服器位址>  是你的 Git 伺服器的位址。 \n \n \n 推送程式碼 ：將程式碼推送到 Git 伺服器： \n \n \n git push -u origin master \n \n \n 這樣可以將本地 master 分支的更改推送到遠端伺服器。 \n \n \n 拉取程式碼 ：如果有其他人在伺服器上修改了程式碼，可以拉取這些更改到本地倉庫： \n \n \n git pull origin master \n \n \n \n \n -進行示範 \n 在示範中，可以展示如何使用 Git 客戶端進行程式碼的提交、推送和拉取操作，以及如何通過 Git 伺服器來協作和管理專案。可以示範一些常見的 Git 命令，例如  git status 、 git log  等，以及如何解決可能出現的衝突等情況。 \n 通過這樣的示範，可以了解如何在 Windows 上使用 Git 來進行版本控制和團隊協作。 \n', 'tags': '', 'url': '議題2.html'}, {'title': 'W8', 'text': '1.教育的本質看課程內容: 培養對 學習的渴望 和 對世界的好奇心， 培養對 學習的渴望 和 對世界的好奇心。 \n \n 廣泛的學習經驗：鼓勵學生 探索不同科目和學科的廣泛教育的重要性 。應該 促進智識好奇心 和 批判性思維 。 \n 2.如何將影片嵌入網頁:上傳影片到youtube上，之後到自己的youtube影片下，點 分享 選擇第一個，把右側 超連結程式 碼複製，編輯網站，點Source code ， 把內容複製貼上。 \n', 'tags': '', 'url': 'W8.html'}, {'title': 'W11', 'text': '', 'tags': '', 'url': 'W11.html'}, {'title': 'Brython程式環境', 'text': "頁面 demo 在同一頁面下入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt \xa0 動態頁面超文件). \n practice_html.txt \xa0 動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為 \xa0 class \xa0 後, 在範例導入時透過 \xa0 instance \xa0 引用 \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:['./../cmsimde/static/','./../downloads/py/']});\n}\n</script> \n 從 1 累加到 100： \n 1 add to 100 \n 將 iterable 與 iterator \xa0 相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n \n \n \n 1 \n 2 \n \n sum \xa0 = \xa0 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 \n \n \n \n \n print ( sum ) \n \n \n \n Filename: \xa0 .py \xa0 \n \n \n \n \n Run\xa0 Output \xa0 清除輸出區 清除繪圖區 Reload \n \n \n \n \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'Brython程式環境.html'}, {'title': '從教務主機直接擷取資料', 'text': '利用 wsgi_v2_py 擷取個學期的課表，輸入"pip list"，再輸入" cd tmp p"→"ython wsgi_v2.py"，完成！ \n \n \n 112學年度第1學期課表 \n \n', 'tags': '', 'url': '從教務主機直接擷取資料.html'}, {'title': 'WCM課程期中整理', 'text': '', 'tags': '', 'url': 'WCM課程期中整理.html'}, {'title': '網頁式內容管理', 'text': '學習議題： \n Q1. 如何建立 Github 上的網站? \n \n \n 建立 GitHub 帳戶：  如果還沒有 GitHub 帳戶，首先需要註冊一個。 \n \n \n 建立一個新的存儲庫（Repository）：  登錄到 GitHub 帳戶後，在頁面右上角找到“+”號圖標，然後選擇“New repository”。給您的存儲庫起一個名字，例如“my-website”，然後選擇公共或私有。 \n \n 準備網站文件： \xa0準備好網站文件，這可能是HTML、CSS、JavaScript和任何圖像或其他資源文件。 \n \n 將網站文件上傳到存儲庫：  使用 Git 命令行工具或 GitHub Desktop，將網站文件上傳到步驟2中創建的存儲庫中。 \n \n \n 啟用 GitHub Pages：  轉到存儲庫設置頁面，滾動到“GitHub Pages”部分。在“Source”下拉菜單中選擇“master branch”（或其他主分支），然後點擊“Save”或“Save changes”。這將存儲庫成為一個網站，並且網站將在以下URL上可用： https://yourusername.github.io/repositoryname。 \n \n \n 等待幾分鐘：  GitHub Pages 服務可能需要幾分鐘時間來構建網站。一旦構建完成，就可以通過 GitHub Pages 網址來查看網站。 \n \n \n 自定義域名（可選）：  如果有自己的域名，並希望使用該域名來訪問網站，可以在存儲庫設置中添加自定義域名 \n \n \n Q2. 如何管理內容? \n \n \n 直接在 GitHub 上編輯： \xa0可以直接在 GitHub 網站上編輯存儲庫中的文件。只需導航到相應的文件，點擊編輯按鈕（鉛筆圖示），然後進行所需的更改。一旦保存更改，網站內容將相應更新。 \n \n \n 使用 Git 工具進行版本控制：  如果更熟悉使用命令行或 Git GUI 工具進行版本控制，可以在本地克隆存儲庫，進行修改，然後推送更改到 GitHub。這種方式能夠更好地管理項目的版本歷史。 \n \n \n 使用分支進行開發： \xa0可以使用 Git 的分支功能來管理不同的開發版本或功能。通過創建新的分支，可以在不影響主要代碼的情況下進行修改和實驗。一旦滿意了新的更改，可以將其合併回主分支。 \n \n \n 利用 GitHub 的協作功能：  GitHub 提供了協作功能，允許多個人共同參與項目。可以邀請其他人共同編輯和管理存儲庫，分配任務，審核代碼等。 \n \n \n 使用 GitHub Pages 的自動構建功能：  如果網站是基於靜態站點生成器（如 Jekyll、Hugo 等）構建的，可以利用 GitHub Pages 的自動構建功能。每當推送新的更改到 GitHub 存儲庫時，GitHub Pages 將自動重新構建並部署網站 \n \n \n Q3. 如何建立章節式網站?\xa0 \n \n \n \n 規劃網站結構：  確定網站的主題和內容，並將其分解成章節和子章節。考慮如何組織信息以及每個章節之間的邏輯關係。 \n \n \n 選擇適合的技術：  根據需求和技能水平選擇適合的技術。對於簡單的靜態網站，可以使用 HTML、CSS 和 JavaScript。如果需要動態內容，可以考慮使用基於框架的解決方案，如React、Vue.js或Angular。 \n \n \n 創建網站頁面：  根據網站結構，創建每個章節和子章節的頁面。每個頁面應該有清晰的標題和內容，並且可以包含導航鏈接以便用戶瀏覽。 \n \n \n 添加導航：  在每個頁面上添加導航菜單或鏈接，以便用戶可以輕鬆地在不同的章節之間進行導航。 \n \n \n 設計和樣式：  使用 CSS 對網站進行設計和樣式設置，使其看起來更吸引人並符合品牌風格。確保設計能夠提高用戶體驗並使內容易於閱讀。 \n \n \n 響應式設計：  確保網站在不同的設備和屏幕尺寸上都能夠正常顯示和運行。使用響應式設計技術來調整和優化網站，以確保用戶在任何設備上都能夠輕鬆訪問內容 \n \n \n \n Q4. 能放入甚麼多媒體內容? 靜態圖文? 動態圖文? 線上遊戲? 3D 零組件展示? \n \n \n \n 靜態圖文： \xa0可以在網站中包含圖像和文字內容，用於說明、展示產品或服務、提供信息等。 \n \n \n 動態圖文： \xa0可以使用動畫效果、滾動效果、視差滾動等技術來使文字和圖像內容更加生動和引人入勝。 \n \n \n 音頻和視頻： \xa0可以嵌入音頻和視頻文件，用於播放音樂、演示視頻、教學視頻等。 \n \n \n 線上遊戲：  如果想要在網站上添加線上遊戲，可以使用HTML5技術和JavaScript來開發和嵌入遊戲，使用戶可以在瀏覽網站時進行遊戲娛樂。 \n \n \n 3D 零組件展示： \xa0可以使用WebGL技術來展示3D模型和場景，使用戶可以在網站上查看和交互3D物體，這在展示產品或專案時特別有用。 \n \n \n 互動式元素： \xa0可以添加各種互動式元素，如表單、地圖、滑塊、照片輪播等，以提供更豐富的用戶體驗 \n \n \n \n Q5. 如何建立網頁系統中的網誌和簡報? \n \n 建立網誌： \n \n \n 選擇靜態網站生成器：  GitHub Pages支援各種靜態網站生成器，如Jekyll、Hugo、Hexo等。選擇一個喜歡的生成器，它們提供了網誌功能並幫助管理內容。 \n \n \n 建立網誌存儲庫：  在GitHub上建立一個新的存儲庫來托管網誌網站。確保將存儲庫的名稱設置為用戶名後面加上.github.io（例如，yourusername.github.io），這樣GitHub就能識別它為網站。 \n \n \n 選擇並配置主題：  選擇一個適合的主題或者根據自己的需求自定義一個。將主題添加到存儲庫中，並根據主題文件進行配置。 \n \n \n 撰寫和發布網誌文章：  使用Markdown或HTML格式撰寫網誌文章，並將它們添加到網誌存儲庫中。每篇網誌文章通常是一個單獨的Markdown文件。提交並推送更改以發布文章。 \n \n \n 設置自動構建和部署：  配置GitHub Actions或其他持續集成工具，以便在每次推送時自動構建和部署網站。這樣，網誌文章將自動更新並在GitHub Pages上發布。 \n \n \n 建立簡報： \n \n \n 選擇簡報工具： \xa0可以使用基於Markdown的工具，如reveal.js或remark.js，或者使用傳統的簡報軟體，如Microsoft PowerPoint、Google Slides等。 \n \n \n 建立簡報文件：  根據選擇的工具，建立一個新的Markdown文件或簡報軟體文件來撰寫簡報內容。對於基於Markdown的工具，可以使用簡單的文本編輯器撰寫簡報內容。 \n \n \n 設計和排版：  設計簡報的佈局和樣式，選擇合適的字體、顏色和排版。確保簡報易於閱讀和吸引人 \n \n \n \n \n', 'tags': '', 'url': '網頁式內容管理.html'}, {'title': 'Python 程式系統', 'text': '學習議題 \n Q1. 如何利用電腦輔助設計室的舊 Python 建立新的可攜環境? \n 要利用Python建立新的可攜環境，可以使用虛擬環境（virtual environment）。這樣可以在不同的專案中管理不同版本的Python和專案相關的套件。 \n \n \n 安裝Python：  如果電腦上沒有Python，首先需要安裝Python。 \n \n \n 安裝虛擬環境工具：  Python自帶了一個名為 venv 的虛擬環境模組，用於建立和管理虛擬環境。無需額外安裝，但也可以選擇使用第三方工具，如 virtualenv 。 \n \n \n 建立虛擬環境：  開啟命令行界面（在Windows下可以使用命令提示符或PowerShell，Mac和Linux下可以使用終端），然後導航到希望建立虛擬環境的目錄。運行以下命令來建立一個名為 myenv 的虛擬環境： \n \n \n python -m venv myenv\n \n \n \n 這將在當前目錄下建立一個名為 myenv 的虛擬環境文件夾。 \n \n \n 啟動虛擬環境：  在建立虛擬環境後，需要啟動它。在命令行界面中運行以下命令： \n \n \n Windows: \n \n \n myenv\\Scripts\\activate \n \n \n \n \n macOS 和 Linux: \n \n \n source myenv/bin/activate\n \n \n \n \n \n 啟動後，將在命令行提示符前看到環境名稱（例如， (myenv) ）。 \n \n \n 安裝相依套件：  在啟動的虛擬環境中，可以使用 pip 命令安裝專案所需的相依套件。例如： \n \n \n pip install package1 package2 ...\n \n \n \n 這將安裝 package1 、 package2 等所需的相依套件。 \n \n \n 使用環境：  在虛擬環境中，可以執行Python腳本和啟動專案，所有安裝的相依套件都將局限於這個環境中。當完成工作時，可以通過輸入 deactivate 命令來退出虛擬環境 \n \n \n Q2.在網頁中置入 Python 語法的程式加上對 Javascript 與超文件語法的了解後, 能夠應用在那些領域? (精密)機械設計流程? 設計運算? 特定系統模擬? \n \n \n \n 精密機械設計流程：  在精密機械設計流程中，可以使用網頁技術來建立交互式的設計工具或模擬器。例如，可以使用Python的科學計算庫（如NumPy、SciPy）來進行工程計算，然後將計算結果與JavaScript和HTML結合，以在網頁上顯示模型、數據可視化或仿真結果。這樣的工具可以幫助工程師快速評估設計方案，優化設計，提高設計效率。 \n \n \n 設計運算：  使用Python在網頁中進行設計運算是一個常見的應用。例如，在建築設計中，可以使用Python來計算結構分析、能源效率等，然後將計算結果呈現在網頁上供用戶查看和分析。同樣地，在機械設計、電子設計等領域也可以應用類似的方法。 \n \n \n 特定系統模擬：  使用Python和JavaScript在網頁中進行特定系統的模擬是另一個重要的應用領域。例如，在物流系統中，可以使用Python模擬貨物的運輸過程，然後使用JavaScript和HTML在網頁上顯示運輸路徑、運輸時間等信息。在人工智慧和機器學習方面，也可以使用Python來建立模型和算法，然後將結果展示在網頁上，用於教育、演示或實時監控 \n \n \n \n \n', 'tags': '', 'url': 'Python 程式系統.html'}, {'title': '網頁上的 IDE', 'text': 'Q1. IDE 是甚麼? \n IDE是「集成開發環境」（Integrated Development Environment）的縮寫。它是一種軟體應用程式，提供了開發人員在單一界面中進行軟體開發所需的各種工具和功能 \n Q2. 可以將 Replit、Codespaces 與 Gitpod 當成 IDE 用來開發各種程式嗎? \n 可以，Replit、Codespaces和Gitpod都可以被視為集成開發環境（IDE），可以用來開發各種類型的程式。它們提供了許多常見IDE的功能，並且可以直接在網頁瀏覽器中運行，不需要在本地計算機上安裝任何軟體。 \n 這些平台主要的功能包括： \n \n \n 原始碼編輯器： \xa0都包含了一個原始碼編輯器，通常支持語法高亮顯示、自動完成、代碼片段等功能。 \n \n \n 調試功能： \xa0提供了調試工具，可以幫助開發人員調試和優化代碼。 \n \n \n 版本控制整合： \xa0支援與版本控制系統（如Git）的集成，使得開發人員可以方便地管理代碼版本。 \n \n \n 項目管理：  可以創建和管理多個項目，並且提供了文件組織和導航功能。 \n \n \n 自動化工具： \xa0支援自動化工具，可以自動化測試、構建和部署流程。 \n \n \n 可擴展性： \xa0支援插件和擴展，可以根據需要安裝各種第三方工具和功能 \n \n \n Q3.與近端操作系統上的開發有何不同? 多人協同? 這樣安全嗎? \n \n 在Replit、Codespaces和Gitpod等基於網頁的開發平台與在本地操作系統上進行開發相比，有幾個主要的不同之處： \n \n \n 環境配置：  在本地操作系統上進行開發時，需要自己配置開發環境，包括安裝適合的編輯器、編程語言解釋器或編譯器、相關的庫和依賴項等。而在基於網頁的開發平台上，這些環境已經預先配置好，只需點擊幾個按鈕就可以啟動開發環境，無需進行任何安裝和配置。 \n \n \n 可移植性：  基於網頁的開發平台可以從任何連接到互聯網的設備上訪問，而不僅僅局限於本計算機。這使得可以從任何地方進行開發工作，只要有互聯網連接。 \n \n \n 多人協同開發：  基於網頁的開發平台通常內建了多人協同開發的功能，這使得團隊成員可以同時在同一個項目上工作，實時查看彼此的修改並進行合併。這一功能在本地開發環境中實現起來相對複雜。 \n \n \n 安全性：  基於網頁的開發平台通常提供了一定程度的安全性，因為所有的代碼和數據都存儲在遠程服務器上，並且根據訪問權限進行管理。然而，這也意味著代碼和數據可能存儲在第三方服務器上，可能存在一定的安全風險。因此，在處理敏感數據或代碼時，需要格外注意安全問題 \n \n \n \n 學習議題：學會使用網頁上的各種 IDE 之後, 有沒有甚麼感想或心得? \n Ans：有了各種IDE工具可以使用，我認為在使用不同的軟體可以更容易地掌握並應用各種工具和技術，非常便捷！ \n', 'tags': '', 'url': '網頁上的 IDE.html'}, {'title': 'AI 工具', 'text': 'Q1. ChatGPT 與 Gemini Pro 都可以直接利用 Gmail 帳號登入, 初級應用目前都可免費使用, 這兩個 AI 工具可以協助我們解決甚麼問題? \n ChatGPT和Gemini Pro都是人工智能工具，可以協助我們解決各種問題，例如： \n \n \n 自然語言理解和生成：  ChatGPT和Gemini Pro都能夠理解自然語言並生成相應的回答或內容。這可以用於處理各種問題，從回答常見問題到生成文本內容等。 \n \n \n 知識問答：  ChatGPT和Gemini Pro可以回答各種問題，並提供相關的資訊和知識。它們可以通過分析大量的資料來回答複雜的問題，並提供準確和有用的解答。 \n \n \n 文本生成和編輯：  ChatGPT和Gemini Pro都可以用於生成文本內容，包括寫作文章、撰寫郵件、製作報告等。可以幫助我們節省時間並提高生產力，特別是在需要大量文本內容的情況下。 \n \n \n 專業領域知識：  Gemini Pro還提供了一些專業領域的AI工具，如Gemini Pro Finance和Gemini Pro Legal等，這些工具可以幫助我們解決特定領域的問題，如財務分析、法律文件處理等 \n \n \n Q2.(1) 為什麼有人驚這些工具為天人?(2) 有人卻覺得還好而已, 並無法從中挖出甚麼資料? \n \xa0 \xa0 \xa0(1)因為只要複製貼上想問的問題，可以在短時間內立即收到答案並且解決問題，而且也能和AI對話、玩遊戲等等。 \n \xa0 \xa0 \xa0(2)我認為其實這些 AI軟體一收到問題只是馬上在網路搜尋大量資料，找到大家都是這樣解決的，並且把其他人以往的解決方法貼給我們看而已，並不是這些AI軟體本身思考過而回答我們的問題 \n \n 學習議題: AI 工具曾經協助我們解決甚麼問題? \n Ans：在公共場合的智慧導覽、iphone上的Siri馬上且簡單的回答想詢問的問題、新聞的AI主播省下主播一直站在螢幕面前的人力等等 \n \n', 'tags': '', 'url': 'AI 工具.html'}, {'title': '實作練習問題', 'text': 'Q4-1. 為什麼 wcm2024 倉儲中的 cms.bat 在 Windows 啟動之後, 若同時多人連線, 系統會無法負荷, 同一台電腦硬體有沒有可能採其他方法啟動, 可以同時讓多人連線且不會產生延遲或停頓的問題?\xa0 \n Ans： 在 Windows 中，當多個用戶同時連線並執行 wcm2024 倉儲中的 cms.bat 時，可能會導致系統負載過重，從而導致延遲或停頓的問題。 \n 解決方法： \n \n \n 使用更高效的硬體資源配置： \xa0 確保電腦擁有足夠的處理器、記憶體和網絡帶寬來應對多個用戶的同時連線需求。這可能意味著升級硬體，或者重新配置現有的硬體資源以優化性能。 \n \n \n 優化程式碼和資源使用： \xa0 檢查 cms.bat 的程式碼，優化它以減少資源使用和提高效率。這可能涉及到改進程式的算法、減少不必要的資源消耗，或者使用更有效率的編譯器和運行時環境。 \n \n \n 使用分散式架構： \xa0 將系統設計為分散式架構，可以將負載分散到多個節點上，從而減輕單個節點的壓力。這樣可以提高系統的擴展性和容錯性，同時減少延遲和停頓的發生概率。 \n \n \n 使用更強大的軟體工具： \xa0 探索是否有其他更適合處理多用戶連線的軟體工具或平台，這些工具可能具有更好的多執行緒支援、資源管理和性能優化功能，從而提供更穩定和高效的服務。 \n \n \n 實施負載平衡： \xa0 使用負載平衡器來動態分配用戶請求到不同的伺服器或節點上，從而平衡系統負載，防止單一節點過度負載而導致延遲或停頓。 \n \n \n \n Q4-2.例如採 wsgi 方式啟動, 這該如何進行?\xa0 \n Ans：想要以WSGI方式啟動程式，首先得確保系統裡裝了一個合適的WSGI伺服器，比如說 mod_wsgi 、 uWSGI 或是 Gunicorn 等等。這些伺服器可以和網頁伺服器，像是Apache或是Nginx一起使用，來處理WSGI應用程式。\n 接著，得把程式改成符合WSGI規範的格式。通常這包括了定義一個叫做 application 的函式，這個函式接收兩個參數（環境變數和回調函式），並回傳一個應答結果。 \n 然後就是要設定WSGI伺服器，確保它能夠運行應用程式。設定的具體步驟會根據使用的WSGI伺服器不同而有所不同，但通常包括指定應用程式的路徑、虛擬主機等等信息。 \n 最後，啟動WSGI伺服器，讓它開始監聽用戶的連線請求。同時確保伺服器能夠妥善處理多個連線，以免出現性能問題。 \n Q4-3. 當設定好讓 Flask 編寫的網際內容管理系統透過效率較高的 wsgi 模式執行後, 如何讓執行程式與電腦開機同步執行? \n Ans： \n \n \n 建立啟動腳本：  創建一個啟動腳本或是服務定義文件，這個腳本負責在系統啟動時啟動你的 Flask 應用程式。在這個腳本中，需要指定適當的環境變數、路徑和其他必要的設定。 \n \n \n 設定自動啟動：  將啟動腳本添加到系統的自動啟動設定中。具體步驟取決於使用的作業系統，例如在 Linux 中，可以將腳本放置在 /etc/init.d/ 目錄下，並使用 update-rc.d 命令來設定自動啟動；而在 Windows 中，可以使用工作管理員或是 Task Scheduler 來設定自動啟動。 \n \n \n 測試設定：  測試設定，確保在系統重新啟動後，Flask 應用程式能夠正常啟動並運行。如果有任何問題，請檢查日誌文件以獲取更多信息，並進行必要的調試和修復。\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n \n \n \n Q4-4. 直接執行套件與透過 Windows services 執行有何不同? \n Ans： \n \n \n 使用者權限：  直接執行套件通常在使用者的上下文中運行，因此僅限於當前登錄的使用者的權限範圍內。而透過 Windows services 執行則可以在系統層級上運行，不受特定使用者權限的限制。 \n \n \n 啟動方式：  直接執行套件通常是由使用者手動啟動，例如雙擊可執行文件或在命令提示字元中運行。而 Windows services 是由系統管理員或自動啟動程序啟動的，可以在系統啟動時自動運行，並且無需使用者登錄或手動啟動。 \n \n \n 生命週期管理：  Windows services 通常具有更完整的生命週期管理功能，包括啟動、停止、暫停和恢復等。這使得服務更容易受益於系統管理工具，例如系統監控、自動化腳本等。 \n \n \n 穩定性和可靠性：  Windows services 通常被視為更穩定和可靠的選擇，因為它們可以在後台運行，無需使用者的交互，並且可以在系統重啟後自動恢復運行狀態。 \n \n \n \n Q4-5. NSSM 是什麼工具? \n Ans：NSSM（Non-Sucking Service Manager）是一個用於在Windows上管理服務的工具。它的主要功能是將任何可執行程序轉換為Windows服務。這代表可以將任何應用程式（如自定義應用程式、腳本或批處理文件）安裝為Windows服務，使其在系統啟動時自動運行，並在後台持續運行。 \n \n Q5. 如何在一台 Windows (Ubuntu) 電腦快速建立多人帳號? 建立多人帳號之後, 如何透過程式將帳號密碼寄給使用者? \n Ans：\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 手動建立帳號：  在 Windows (Ubuntu) 中，可以通過控制面板 (Windows) 或是使用者管理命令（Ubuntu）來手動建立多個使用者帳號。在控制面板中，可以進入「使用者帳號」設定來建立新的使用者。在 Ubuntu 中，可以使用  adduser  或  useradd  命令來創建新的使用者帳號。 \n \n \n 批量建立帳號：  如果需要快速建立多個帳號，可以使用自動化腳本來批量建立帳號。在 Windows 中，你可以使用 PowerShell 或是批處理腳本來批量建立帳號；在 Ubuntu 中，可以使用 Shell 腳本或是其他自動化工具來達到相同的目的。 \n \n \n 設定帳號權限：  確保為每個帳號設定適當的權限和許可權，以確保使用者可以正確地訪問所需的資源和功能。 \n \n \n 至於如何透過程式將帳號密碼寄給使用者，這是一個稍微複雜的問題。一般來說，為了安全起見，密碼不應該以明文形式在郵件中傳送，因為這樣會增加密碼外泄的風險。 \n 取而代之的方法是，可以在建立帳號時要求使用者提供自己的密碼，並在密碼設定完成後，通過安全的方式通知使用者他們的帳號已經建立。這可能包括發送一封包含登錄說明的郵件，或是提供一個安全的網頁來顯示帳號詳細信息。 \n 如果確實需要通過郵件將密碼傳送給使用者，請確保使用了安全的方式，例如使用加密連接（如TLS）和安全的郵件傳輸協議（如SMTPS）。 \n Q6.承接上一題: 一個採用 Flask 編寫的伺服器系統, 該如何在 Windows 環境中以 wsgi 方式啟動? \n Ans： \n \n \n 安裝WSGI伺服器： \xa0需要在Windows系統上安裝一個WSGI伺服器，例如mod_wsgi、uWSGI或Gunicorn。可以使用pip安裝相應的Python套件，例如 pip install mod_wsgi 。 \n \n \n 準備Flask應用程式：  確保Flask應用程式（app.py或其他命名的主程式文件）符合WSGI規範。這意味著需要定義一個 application 的WSGI應用程式對象，並將Flask應用程式實例作為返回值。例如： \n from flask import Flask\napp = Flask(__name__)\n\n@app.route(\'/\')\ndef hello():\n    return \'Hello, World!\'\n\napplication = app # Flask應用程式實例命名為`application`\n \n 3.配置WSGI伺服器：  配置你選擇的WSGI伺服器以運行Flask應用程式。這涉及指定應用程式的路徑、虛擬主機等信息。具體的配置步驟取決於你選擇的WSGI伺服器。 \n 4.啟動WSGI伺服器：  使用配置好的WSGI伺服器來啟動Flask應用程式。你可以在命令提示字元中執行相應的命令來啟動WSGI伺服器，並確保伺服器正確運行。 \n 5.測試：  測試你的Flask應用程式是否能夠正常運行。你可以使用瀏覽器或HTTP客戶端工具向Flask應用程式發送請求，並確認你能夠收到正確的響應。 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Q7.wcm2024 課程中曾經提到可以利用舊的可攜 Python 程式環境建立新的 Python 可攜程式環境, 但該如何進行? \n \n \n 下載可攜 Python 發行版： \xa0需要下載一個可攜 Python 的發行版。可攜 Python 是一個獨立於系統安裝的Python發行版，可以直接在任何地方運行，而不需要進行系統安裝。可以從Python官方網站下載可攜 Python 的zip或tarball壓縮文件。 \n \n \n 解壓縮：  下載完成後，將壓縮文件解壓縮到想要放置Python環境的目錄中。可以將它解壓縮到任何位置，例如用戶文件夾或移動存儲設備。 \n \n \n 複製舊的可攜 Python 環境：  如果已經有一個舊的可攜 Python 環境，複製該環境中的所有內容到新的位置。這將包括Python解釋器、標準庫、第三方庫以及任何已安裝的額外組件。 \n \n \n 設置環境變數（可選）：  如果希望在命令提示字元或終端中使用新的可攜 Python 環境，可能需要設置相應的環境變數。這通常涉及將Python解釋器的路徑添加到系統的PATH環境變數中。 \n \n \n 測試新的 Python 環境：  確保新可攜 Python 環境可以正常運行。可以在命令提示字元或終端中運行 python 命令，並確認能夠進入Python解釋器的交互模式。 \n \n \nQ8.假如希望直接在網頁中利用 Brython 建立一個掃地機器人的工作模擬系統, 該如何進行?\n Ans：\n \n \n 準備 HTML 檔案：  創建一個 HTML 檔案，用於顯示掃地機器人模擬系統的介面。你可以使用 HTML 標籤來建立控制按鈕、顯示區域等元素。 \n \n \n 引入 Brython：  在 HTML 檔案中引入 Brython 的 JavaScript 庫，以便在網頁中執行 Python 代碼。你可以通過在  <head>  標籤中添加以下代碼引入 Brython： \n <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython.min.js"></script>\n \n \n \n 編寫 Python 代碼：  在 HTML 檔案中使用  <script type="text/python">  標籤來編寫 Python 代碼。你可以使用 Python 來模擬掃地機器人的移動、清潔路徑、檢測障礙物等操作。 \n \n \n 整合 HTML 和 Python 代碼：  將 HTML 檔案中的 Python 代碼與 HTML 元素整合在一起，以實現掃地機器人模擬系統的功能和界面。 \n \n \n 測試和調試：  在瀏覽器中打開 HTML 檔案，測試掃地機器人模擬系統的功能。通過與控制按鈕互動，確保掃地機器人能夠正確地模擬工作。 \n \n \n \n Q9.wcm2024 課程除了可以使用 \xa0 ChatGPT \xa0 外, 還能夠使用 Google \xa0 Gemini Pro , 請試著在解決上列問題時, 善用這兩個系統, 並將使用過程與心得整理在個人的課程網頁與網誌中。 \n Ans：在使用ChatGPT時，把問題丟給它可以立即得到回應，相當方便。但如果利用中文對話，有時候它會一直使用簡體字，但我們慣用繁體，所以當它利用簡體字回應時，每次都要再重新跟它說使用繁體字回答，使用上就有些麻煩。 \n', 'tags': '', 'url': '實作練習問題.html'}, {'title': '期末專案', 'text': '用Python寫出圈圈叉叉遊戲(井字遊戲) \n 首先，需要一個表示遊戲棋盤的資料結構，可以使用一個列表列表（list of lists）來表示棋盤，每個元素代表一個格子，初始為空', 'tags': '', 'url': '期末專案.html'}, {'title': '1.定義棋盤大小', 'text': '棋盤大小為3x3 \n # 定義棋盤大小\nROWS = 3\nCOLS = 3', 'tags': '', 'url': '1.定義棋盤大小.html'}, {'title': '2.初始化棋盤', 'text': "board = [[' ' for _ in range(COLS)] for _ in range(ROWS)] \n \n \n [[' ' for _ in range(COLS)] for _ in range(ROWS)] : 這是一個列表推導式（list comprehension），用於創建一個二維列表（也就是列表的列表），每個元素都是一個空格  ' ' ，該列表的大小是ROWS × COLS，也就是棋盤的大小。 \n \n \n for _ in range(ROWS) : 在這個列表推導式中，我們使用  _  來表示不關心的迭代變數。使用  for _ in range(ROWS)  來迭代  range(ROWS)  中的值，這確保將ROWS × COLS個  ' '  添加到的棋盤中。 \n \n \n 這段程式碼創建了一個大小為ROWS × COLS的二維列表，其中每個元素都是一個空格，這代表了遊戲開始時的空棋盤", 'tags': '', 'url': '2.初始化棋盤.html'}, {'title': '3.顯示棋盤的函式', 'text': '# 顯示棋盤的函式\ndef display_board(board):\n    for row in board:\n        print(\'|\'.join(row))\n        print(\'-\' * (2 * COLS - 1)) \n \n "for row in board:" ：這個迴圈遍歷棋盤中的每一行。 \n "print(\'|\'.join(row))" ：對於每一行，使用 \'|\'.join(row) 來將該行的所有元素連接成一個字符串，以\'|\'分隔。這樣可以打印出該行的樣子，就像遊戲棋盤一樣，例如： X| |O 。 \n print(\'-\' * (2 * COLS - 1)) ：在打印完每一行後，打印一行橫線，用來分隔每一行。這一行的長度是棋盤寬度的兩倍再減去一，因為每個格子之間有一個\'|\'。 \n \n 當調用 display_board 函式並傳遞遊戲棋盤時，它會以視覺化的方式在終端上打印出遊戲棋盤的樣子，讓玩家可以清楚地看到目前的遊戲狀態', 'tags': '', 'url': '3.顯示棋盤的函式.html'}, {'title': '4.檢查是否有玩家贏得遊戲', 'text': 'def check_win(board, player):\n    # 檢查每一行\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    # 檢查每一列\n    for col in range(COLS):\n        if all(board[row][col] == player for row in range(ROWS)):\n            return True\n    # 檢查對角線\n    if all(board[i][i] == player for i in range(ROWS)):\n        return True\n    if all(board[i][COLS - i - 1] == player for i in range(ROWS)):\n        return True\n    return False\n \n \n \n "for row in board:" ：這個迴圈遍歷了棋盤的每一行。 \n \n if all(cell == player for cell in row): ：對於每一行，這個條件檢查是否所有的格子都是由 player 所標記。如果是，則返回 True ，表示玩家贏得了比賽。 \n \n \n \n "for col in range(COLS):" ：這個迴圈遍歷了棋盤的每一列。 \n \n if all(board[row][col] == player for row in range(ROWS)): ：對於每一列，這個條件檢查是否所有的格子都是由 player 所標記。如果是，則返回 True ，表示玩家贏得了比賽。 \n \n \n \n 對角線檢查： \n \n if all(board[i][i] == player for i in range(ROWS)): ：這個條件檢查主對角線是否所有的格子都是由 player 所標記。如果是，則返回 True ，表示玩家贏得了比賽。 \n if all(board[i][COLS - i - 1] == player for i in range(ROWS)): ：這個條件檢查副對角線是否所有的格子都是由 player 所標記。如果是，則返回 True ，表示玩家贏得了比賽。 \n \n \n \n 如果以上條件都不符合，則返回 False ，表示沒有玩家贏得比賽。 \n \n \n 當調用 check_win 函式並傳遞遊戲棋盤和玩家標記時，它將檢查是否有玩家在任何行、列或對角線上贏得了比賽，並返回相應的結果', 'tags': '', 'url': '4.檢查是否有玩家贏得遊戲.html'}, {'title': '5.主遊戲迴圈', 'text': 'def main():\n    current_player = \'X\'\n    while True:\n        display_board(board)\n        print(f"Player {current_player}\'s turn")\n        row = int(input("Enter row (0, 1, 2): "))\n        col = int(input("Enter column (0, 1, 2): "))\n\n        # 檢查是否合法\n        if 0 <= row < ROWS and 0 <= col < COLS and board[row][col] == \' \':\n            board[row][col] = current_player\n            if check_win(board, current_player):\n                display_board(board)\n                print(f"Player {current_player} wins!")\n                break\n            elif all(cell != \' \' for row in board for cell in row):\n                display_board(board)\n                print("It\'s a tie!")\n                break\n            else:\n                # 切換玩家\n                current_player = \'O\' if current_player == \'X\' else \'X\'\n        else:\n            print("Invalid move! Try again.")\n\nif __name__ == "__main__":\n    main() \n \n \n current_player = \'X\' ：初始化當前玩家為 \'X\'。 \n \n \n while True: ：這是一個無限迴圈，直到有玩家贏得比賽或者平局才會結束。 \n \n \n display_board(board) ：在每一輪遊戲開始時顯示當前棋盤的狀態。 \n \n \n print(f"Player {current_player}\'s turn") ：打印當前輪到哪個玩家。 \n \n \n row = int(input("Enter row (0, 1, 2): "))  和  col = int(input("Enter column (0, 1, 2): ")) ：讓玩家輸入他們想要下子的位置。 \n \n \n 檢查是否合法：確保玩家的輸入是有效的，即檢查玩家是否在有效範圍內輸入並且該位置是否為空。 \n \n \n 如果輸入合法，則在棋盤上放置當前玩家的標記。 \n \n \n 使用 check_win 函式檢查遊戲是否結束，如果有一方贏得了比賽，則顯示相應的訊息並結束遊戲。 \n \n \n 如果沒有玩家贏得比賽，則檢查是否所有的格子都已經被填滿，如果是，則宣布平局並結束遊戲。 \n \n \n 如果遊戲還沒有結束，則切換到另一個玩家，然後繼續下一輪遊戲。 \n \n \n 如果玩家的輸入不合法，則提示玩家重新輸入。 \n \n \n 運行這段程式碼時，它將模擬一個井字遊戲，並允許兩個玩家交替下棋，直到其中一方贏得比賽或者達到平局為止', 'tags': '', 'url': '5.主遊戲迴圈.html'}, {'title': '完整程式碼', 'text': '# 定義棋盤大小\nROWS = 3\nCOLS = 3\n\n# 初始化棋盤\nboard = [[\' \' for _ in range(COLS)] for _ in range(ROWS)]\n\n# 顯示棋盤的函式\ndef display_board(board):\n    for row in board:\n        print(\'|\'.join(row))\n        print(\'-\' * (2 * COLS - 1))\n\n# 檢查是否有玩家贏得遊戲\ndef check_win(board, player):\n    # 檢查每一行\n    for row in board:\n        if all(cell == player for cell in row):\n            return True\n    # 檢查每一列\n    for col in range(COLS):\n        if all(board[row][col] == player for row in range(ROWS)):\n            return True\n    # 檢查對角線\n    if all(board[i][i] == player for i in range(ROWS)):\n        return True\n    if all(board[i][COLS - i - 1] == player for i in range(ROWS)):\n        return True\n    return False\n\n# 主遊戲迴圈\ndef main():\n    current_player = \'X\'\n    while True:\n        display_board(board)\n        print(f"Player {current_player}\'s turn")\n        row = int(input("Enter row (0, 1, 2): "))\n        col = int(input("Enter column (0, 1, 2): "))\n\n        # 檢查是否合法\n        if 0 <= row < ROWS and 0 <= col < COLS and board[row][col] == \' \':\n            board[row][col] = current_player\n            if check_win(board, current_player):\n                display_board(board)\n                print(f"Player {current_player} wins!")\n                break\n            elif all(cell != \' \' for row in board for cell in row):\n                display_board(board)\n                print("It\'s a tie!")\n                break\n            else:\n                # 切換玩家\n                current_player = \'O\' if current_player == \'X\' else \'X\'\n        else:\n            print("Invalid move! Try again.")\n\nif __name__ == "__main__":\n    main()\n \n', 'tags': '', 'url': '完整程式碼.html'}, {'title': '成品', 'text': '圈圈叉叉-41223104.mp4 \n', 'tags': '', 'url': '成品.html'}, {'title': 'cmsimde', 'text': "SMap  - SiteMap - 依照階次列出網站的所有頁面. \n EditA  - Edit All page - 將所有頁面放入編輯模式中, 主要用來處理頁面搬遷, 刪除或決定衝突頁面內容版本. \n Edit  - Edit page - 先選擇要編輯的單一頁面後, 再點選 Edit, 即可進入單一頁面的編輯模式. \n Config  - Configure Site - 編輯頁面標題與管理者密碼. \n Search  - 動態頁面內容的關鍵字搜尋. \n IUpload  - Image file Upload - 圖檔的上傳功能, 可以上傳 jpg, png 與 gif 檔案, 其中若在手機上傳圖檔, 系統會自動將圖片檔案縮小為 800x800 大小. \n IList  - Image file List - 列出可以直接在頁面編輯模式中引用的圖片檔案. \n FUpload  - File Upload - 一般檔案的上傳功能, 目前可以上傳的檔案副檔名包括 'jpg', 'png', 'gif', '7z', 'pdf', 'zip', 'ttt', 'stl', 'txt', 'html', 'mp4' 等, 使用者可以自行修改. \n FList  - File List - 列出可以直接在頁面編輯模式中引用的上傳檔案. \n Logout  - 登出頁面編輯模式. \n Convert  - 將動態網站中位於 config/content.htm 檔案, 透過分頁設定轉為 content 目錄中的靜態網頁. \n acp  - git add, git commit 與 git push, 通常只有在 localhost 或自架主機上利用網頁表單協助將倉儲改版內容推向 Github 倉儲. \n SStatic  - Start Static Site - 利用 Python 啟動網站伺服功能, 可以讓使用者檢查轉檔後的靜態網站內容. \n RStatic  - Replit Static Site URL - 僅用於 Replit 模式, 當使用者按下 SStatic 後, 可以按下 RStatic 進入當下尚未推向 Github Pages 的靜態網站. \n 80  - 由 init.py 中 static_port 所決定的連結字串, 一般不使用 80, 只有在 Replit 中為了與動態網站共用 port, 才特別設為 80. \n \n", 'tags': '', 'url': 'cmsimde.html'}, {'title': 'Replit', 'text': 'https://replit.com \n 利用 init_replit 指令安裝所需 Python 模組 chmod u+x init_replit ./init_replit \n On Replit: \n .replit: python3 main.py \n chmod u+x cms init_replit \n ./init_replit \n for cmsimde_site (not needed): git submodule update --init --recursive \n for cmsimde: pip install flask flask_cors bs4 lxml pelican markdown gevent \n password generator:\xa0 https://mde.tw/cmsite/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/b92b16621dd0246c352cf13d6463b333/raw/0bfa669750aba3abe48554509bbd43d65b6e5c82/hashlib_password_generator.py \xa0 \n \n for IPv6 only Ubuntu: .ssh 目錄中的 config, 將 SSH session 名稱設為 github.com: Host github.com User git Hostname github.com ProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p for Replit: .ssh 目錄中的 config, 將 SSH session 名稱設為 github.com: Host github.com User git Hostname github.co #since Replit works for IPv4, therefore no ProxyCommand setting needed #ProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p \n \n \n', 'tags': '', 'url': 'Replit.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}]};